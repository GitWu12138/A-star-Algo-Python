

import numpy as np
import timeit


##########################################3
    
def ray_cast(grid1,grid2,col): #note is the grid state that is occupied in between found by R_C Algo
    x2 = int(grid2)/col; y2 = int(grid2)%col
    x1 = int(grid1)/col; y1 = int(grid1)%col
    rd = x2 - x1; # Row difference
    cd = y2 - y1; # Column difference
    diff = abs(rd) - abs(cd);
     
    # Some intialization

    x_inc = 1 if (x2>x1) else -1
    y_inc = 1 if (y2>y1) else -1
    n = int(1+ abs(rd) + abs(cd))
    
        # Identifying the two joining lines of the grid based on qurdrant of travel
    if (rd>0 and cd<0) or (rd<0 and cd>0):
        x1_a = x1-0.5; y1_a = y1-0.5; x1_b = x1+0.5; y1_b = y1+0.5;
        
    if (rd>0 and cd>0) or (rd<0 and cd<0):
        x1_a = x1-0.5; y1_a = y1+0.5; x1_b = x1+0.5; y1_b = y1-0.5;
    if (rd == 0):
        x1_a = x1-0.5; x1_b = x1+0.5; y1_a = y1; y1_b = y1;
    if (cd == 0):
        y1_a = y1-0.5; y1_b = y1+0.5; x1_a = x1; x1_b = x1;

    rd_new = abs(rd)*2; cd_new = abs(cd)*2;
    ray_grid_list = [[],[]]
     
    for j in range(2):
        x_k = x1; y_k = y1;
        x = x1_a if (j==0) else x1_b;
        y = y1_a if (j==0) else y1_b;
        #diff = abs(rd) - abs(cd);
        for i in range(1,n):
            if (diff > 0):
                diff -= cd_new; x_i = x + x_inc;
                x_j = (x + x_i)/2; # add this to a list of grids
                ray_grid_list[j].append(int(col*x_j + y_k)); # earlier this line was (ray_grid_list.append(col*x_j + y_k));
                ### Be careful !!! dividing with 'col' and again multiplying with 'col' might not result in same value!!!
                x = x_i; x_k = x_j; 
            else :
                diff += rd_new; y_i = y + y_inc;
                y_j = (y + y_i)/2; # add this to a list of grids
                ray_grid_list[j].append(int(col*x_k + y_j)) # earlier this line was (ray_grid_list.append(col*x_k + y_j))
                y = y_i; y_k = y_j;

    if (rd ==1) or (cd==1):
        y = y1; x = x1; count =0;
        occ = 2*(abs(cd)) + 2*(abs(rd))
        for i in range(abs(cd)+1):
            x = x1;
            for j in range(abs(rd)+1):
                count +=1; t = col*x + y;
                if (count <= occ/2):
                    if t not in ray_grid_list[0]: ray_grid_list[0].append(int(t))
                else:
                    if t not in ray_grid_list[1]: ray_grid_list[1].append(int(t)) 
                x = x + x_inc;
            y = y + y_inc;     

    return(ray_grid_list);

## END of Ray_Cast Program


''' Line of Sight Algorithm'''

def line_of_sight_1(grids,s_s,end_s,col,neg_r):

    ray_grid_list = [[],[]];
    occupied =[]; state_remove = []
    state_add =[s_s]
   
    current_cell = s_s; j =1;
    next_cell = grids[j];x
    check_cell = grids[j+1];
    #neighbours = []
    while(check_cell != end_s):
        check_cell = grids[j+1];
        ray_grid_list = ray_cast(current_cell,check_cell,col);
        occupied = []
        for p in (ray_grid_list[0],ray_grid_list[1]):
            occupied += [t for t in p if t in neg_r];
        #print occupied
        '''for p in (current_cell,check_cell):   # To get the neighbours for both current and check cells)
            neighbours += [p+1,p-1,p+col+1,p+col-1,p-col+1,p-col-1,p+col,p-col]
            ## neigbours of current and check grids can be removed from 'occupied' list so that path can be generated by shofting to nearest neighbours
        #ray_grid_list[0].remove(u for u in neighbours if u in ray_grid_list[0])
        for p in occupied: ## This is applicable when MBPP is performed and single line chk is carried
            if p in neighbours:
                occupied.remove(p);
        '''
        occup =[] 
        if (len(occupied)!=0): 
            if(check_cell/col == next_cell/col)or(check_cell%col == next_cell%col):
                state_add += [next_cell];
            else:
                # note the common vertex neighbour for both the new and its previous state
                neighb1 = [check_cell+1,check_cell-1,check_cell+col+1,check_cell+col-1,check_cell-col+1,check_cell-col-1,check_cell+col,check_cell-col]
                neighb2 = [next_cell+1,next_cell-1,next_cell+col+1,next_cell+col-1,next_cell-col+1,next_cell-col-1,next_cell+col,next_cell-col]
                occup = [t for t in neighb1 if (t in neighb2 and t not in neg_r)]; ''' BE CAREFUL --- The above line might result in list having multiple states for occup, but occup need only one commmon state - one possible solution is make occup a list of unknown vector size, and keep adding all the common elements to neigh1 and neigh2, then consider one state that among all occup list thta has a neighbour in neg_r'''
                state_add += [occup[0]];
            if len(occup) != 0: current_cell = occup[0];
            #current_cell = occup[0];
        '''if (check_cell != end_s):
            next_cell = check_cell;'''
        next_cell = check_cell; j +=1;
    if end_s not in state_add: state_add += [end_s];
    
    return(state_add);

# ------------------------------------

start = timeit.default_timer()

ro = 2 + int(input("  Enter the number of rows of Grid :"))
co = 2 + int(input("  Enter the number of columns of Grid :"))
print("\n")
print("Grid cells are numbered as :")
print("\n")

# To print the states of the environment

k = ro
for i in range(1, ro-1):
    print(" ")
    for j in range(1, co-1):
        k += 1
        print(" "), #comma (,) at the end of print statement helps
        print(k),   # in avoiding printing of new line each time
    k += 2
    print("\n")        


print("\n")
print(" ------ From the states indicated above ------ ")
print("\n")
s_s = int(input("  Enter your desired start state:"))
end_s = int(input("  Enter the state of max reward (end state) :"))

grid = [[0 for row in range(co)] for col in range(ro)]
'''init = [s_s\col,s_s%col];
goal = [end_s\col'''
delta = [[0,1],[1,1],[1,0],[1,-1],[0,-1],[-1,-1],[-1,0],[-1,1]]
init =[s_s/co, s_s%co]; goal = [end_s/co, end_s%co]
cost = 1
#delta_name = ['>',''\'','v',''/'','<',''\'','^',''/''];
#delta_name = ['>',''\'','v',''/'','<',''\'','^',''/''];
delta_name = ['>','SE','V','SW','<','NW','^','NE'];

#rr[end_s/col,end_s%col] = 1200

print("\n")
print(" Enter the set of index of the states (shown in the above "),
print(" indexed number table) that has puddle in it ")
print(" Leave space between each entered index number, once you "),
print(" are done with entering no's, press ENTER ")
print("\n")

see = raw_input("Enter index list here  : ")
neg_r = [int(i) for i in see.split()] # to get the count of entered inputs
n_k = len(neg_r)

for i in range(n_k):
    grid[neg_r[i]/co][neg_r[i]%co] = 1

heuristic =[[0 for row in range(co)] for col in range(ro)]

x = goal[0]
y = goal[1]
# heuristic using Eucledian distance
'''for i in range(ro):
    for j in range(co):
        d = (x-i)**2 + (y-j)**2        
        heuristic[i][j] = round(math.sqrt(d),2)
'''
# heuristic using Diagonal distance
for i in range(1, ro-1):
    for j in range(1, co-1):
        dx = abs(x-i)
        dy = abs(y-j)
        d2 = (np.sqrt(2) - 2)*(min(dx,dy))
        heuristic[i][j] = round(dx+dy+d2)

def search():
    closed=[[0 for row in range(co)] for col in range(ro)]
    expand=[[-1 for row in range(co)] for col in range(ro)]
    count=0
    action=[[-1 for row in range(co)] for col in range(ro)]

    closed[init[0]][init[1]] = 1
    x = init[0]; y = init[1]
    g = 0
    h = heuristic[x][y]
    f = g + h
    opened = [[f,g,h,s_s]]
    found = False; resign = False
    while (found is False) and (resign is False):
        if(len(opened) == 0):
            resign = True
            print "Fail"
        else:
            opened.sort()
            opened.reverse()
            nextt = opened.pop()
            x = nextt[3]/co; y = nextt[3]%co; g = nextt[1]

            expand[x][y] = count
            count += 1

            if x==goal[0] and y==goal[1]:
                found = True
                #print nextt
            else :
                for i in range(len(delta)):
                    x2 = x + delta[i][0]
                    y2 = y + delta[i][1]
                    if (x2>=1 and ro-1>x2)and(y2>=1 and co-1>y2):
                        if (closed[x2][y2]==0)and(grid[x2][y2]==0):
                            g2 = g+cost
                            h2 = heuristic[x2][y2]
                            f2=g2+h2
                            opened.append([f2,g2,h2,(co*x2+y2)])
                            closed[x2][y2] = 1 
                            action[x2][y2] = i
    #print '\n Heuristic table \n'                            
    '''for i in range(len(heuristic)):
        print heuristic[i]

    print '\n'
    print '\n Expand table \n'    
    for i in range(len(expand)):
        print expand[i]'''
    print '\n\n'

    if resign == True:
        print "\n There is no navigable path in the given environment ";
    else:
        #policy = [[' ' for row in range(len(grid[0]))] for col in range(len(grid[1]))]
        x = goal[0]; y = goal[1];
        path_note = [end_s]
        #policy[x][y] = '*';
        while x != init[0] or y != init[1]:
            x2 = x - delta[action[x][y]][0]
            y2 = y - delta[action[x][y]][1]
            #policy[x2][y2] = delta_name[action[x][y]]
            x = x2
            y = y2
            path_note += [(co*x + y)];
        print path_note
        #print (co*x+y)
        '''for i in range(len(policy)):
              print policy[i]'''
        path_note.reverse()

        #Line of Sight algorithm to remove bypass states taht are visible

        new_path_list = line_of_sight_1(path_note,s_s,end_s,co,neg_r);


        print "Choosen states for path after Post smoothening : \n"
        print new_path_list

        grids = new_path_list;

        dist = 0
        for j in range(len(grids)-1):
            x = (grids[j+1]/co-(grids[j])/co)**2 # ** stands for square
            y = (grids[j+1]%co-(grids[j])%co)**2
            dist += np.sqrt(x+y)

        print "\n", "  Distance of the chosen path is :  ", dist

# Main function that actually does A* is below
search()

# reverse the obtained path which actually starts with end_s and travel back


stop = timeit.default_timer()

print '\n\n Time taken to run this program :'
print stop - start

# To print memory usage
import os
import psutil
process = psutil.Process(os.getpid())
print process.memory_info().rss

# setting Heuristic to the entire grid
